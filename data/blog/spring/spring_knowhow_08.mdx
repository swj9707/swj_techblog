---
title: '[ì•Œê³ ì“°ì] Spring - 08 : Transactional'
date: '2025-05-12'
lastmod: '2025-05-12'
tags: ['Spring', 'Backend', 'Study']
draft: false
layout: PostBanner
images: ['https://download.logo.wine/logo/Spring_Framework/Spring_Framework-Logo.wine.png']
summary: ì•Œê³ ì“°ì ì‹œë¦¬ì¦ˆ. @Transactional ì–´ë…¸í…Œì´ì…˜ì— ëŒ€í•´ ê¹Šê²Œ íŒŒê³ ë“¤ì–´ ë³¼ê¹Œìš”?
---

# ğŸƒ Intro

ë‹¤ì‹œ ëŒì•„ì™”ìŠµë‹ˆë‹¤. Spring ìœ¼ë¡œ ì—´ì‹¬íˆ JSON ì„ ìƒí•˜ì°¨ ì¤‘ì¸ ì†ìš°ì§„ì…ë‹ˆë‹¤.  
ë°±ì—”ë“œ ê°œë°œìì—ê²Œ Transaction ì´ë¼ëŠ” í‚¤ì›Œë“œëŠ” ì£½ì–´ë„ ë•” ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„°ë¥¼ DBì—ì„œ ì ì ˆí•˜ê²Œ ê°€ê³µí•´ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ ì €ì¥í•˜ëŠ” ëª¨ë“  ì¼ë ¨ì˜ ê³¼ì •ì€ í•˜ë‚˜ì˜ ì‘ì—… ë‹¨ìœ„ë¡œ ë‚˜ë‰©ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì´ë ‡ê²Œ ë‚˜ëˆŒ ìˆ˜ ì—†ëŠ” í•˜ë‚˜ì˜ ì‘ì—… ë‹¨ìœ„ë¥¼ `Transaction` ì´ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.

Spring ì—ì„œëŠ” Transaction ì„ ì–´ë–»ê²Œ ê´€ë¦¬í• ê¹Œìš”? ì•„ë¬´ê²ƒë„ ì„¤ì •í•˜ì§€ ì•Šì€ ê²½ìš°ì—” `Auto Commit` ëª¨ë“œê°€ í™œì„±í™” ë©ë‹ˆë‹¤. ë‚ ì•„ê°€ëŠ” ì¿¼ë¦¬ ì¡±ì¡± ìë™ìœ¼ë¡œ ì»¤ë°‹ì´ ë˜ì–´ë²„ë¦¬ì£ . ì‚¬ì‹¤ ê·¸ëƒ¥ **Read** ë§Œ í•˜ëŠ” ê²½ìš°ë¼ë©´ í¬ê²Œ ë¬¸ì œê°€ ì—†ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤ë§Œ **Create**, **Update**, **Delete** ì—ì„œëŠ” ë¬¸ì œê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§Œì•½ ë¬¸ì œê°€ ë°œìƒí•œ ê²½ìš° ë¡¤ë°±í•˜ê¸°ê°€ ìƒë‹¹íˆ ê³¤ë€í•´ì§ˆ ìˆ˜ ìˆê² ì£ . ì‚¬ëŒì´ ì¼ì¼íˆ ì†ìœ¼ë¡œ ë¡¤ë°±í•´ì£¼ëŠ” ê²½ìš°ê°€ ì¼ì–´ë‚˜ê¸¸ ë°”ë¼ëŠ” ì‚¬ëŒì€ ë§ì§€ ì•Šì„ ê²ƒì´ë¼ ìƒê°í•©ë‹ˆë‹¤.

ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•´ì¤„ ìˆ˜ ìˆëŠ” `@Transactional` ì–´ë…¸í…Œì´ì…˜ì— ëŒ€í•´ ë‹¤ë¤„ ë³´ê² ìŠµë‹ˆë‹¤.

# âš™ï¸ Transaction ì´ ê°€ì§€ëŠ” ì£¼ìš” ì†ì„±

ì „ê³µì—ì„œ í˜¹ì€ ì •ë³´ì²˜ë¦¬ê¸°ì‚¬ ì‹œí—˜ ë“±ì—ì„œ ë°ì´í„°ë² ì´ìŠ¤ ì´ë¡ ì— ëŒ€í•´ ë°°ìš¸ ë•Œ ë°˜ë“œì‹œ ê³µë¶€í•˜ê²Œ ë˜ëŠ” ê²ƒì´ Transaction ì˜ ì£¼ìš” ì†ì„± **ACID** ì…ë‹ˆë‹¤. ë‹¤ë“¤ ì˜ ì•„ì‹œê² ì§€ë§Œ ë¦¬ë§ˆì¸ë“œ ì‚¼ì•„ í•œë²ˆ ì§šê³  ë„˜ì–´ê°€ê² ìŠµë‹ˆë‹¤.

- **ì›ìì„± (Atomicity)** : ëª¨ë“  ì‘ì—…ì´ ì„±ê³µí•˜ê±°ë‚˜ ëª¨ë‘ ì‹¤íŒ¨í•´ì•¼ í•¨.
- **ì¼ê´€ì„± (Consistency)** : íŠ¸ëœì­ì…˜ì´ ì™„ë£Œë˜ë©´ ë°ì´í„°ê°€ ì¼ê´€ëœ ìƒíƒœì—¬ì•¼ í•¨.
- **ê³ ë¦½ì„± (Isolation)** : íŠ¸ëœì­ì…˜ ê°„ì˜ ì‘ì—…ì´ ì„œë¡œ ê°„ì„­í•˜ì§€ ì•ŠìŒ.
- **ì§€ì†ì„± (Durability)** : íŠ¸ëœì­ì…˜ì´ ì™„ë£Œë˜ë©´ ê·¸ ê²°ê³¼ëŠ” ì˜êµ¬ì ìœ¼ë¡œ ë°˜ì˜ë¨.

# ğŸ§ @Transactional ë™ì‘ ì›ë¦¬

ì§€ë‚œ í¬ìŠ¤íŒ…ì—ì„œ Spring ì˜ AOP ì— ëŒ€í•´ ìì„¸íˆ ë‹¤ë£¬ ì ì´ ìˆìŠµë‹ˆë‹¤. Spring ì˜ `@Transactional` ì–´ë…¸í…Œì´ì…˜ì€ í”„ë¡ì‹œ ê¸°ë°˜ AOP ë¥¼ ì‚¬ìš©í•´ì„œ ë©”ì†Œë“œ ì‹¤í–‰ ì „í›„ì— Transaction ê²½ê³„ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì•„ë§ˆë„...ì§€ë‚œ í¬ìŠ¤íŒ…ì„ ë‹¤ì‹œ ìì„¸íˆ ë³´ì‹œê¸°ì—” ì‹œê°„ì´ ë¹¡ë¹¡í•˜ê±°ë‚˜ í•  ìˆ˜ ìˆìœ¼ë‹ˆ ê°„ë‹¨í•˜ê²Œë§Œ ë¦¬ë§ˆì¸ë“œ í•˜ìë©´, Spring IOC ê°€ ê´€ë¦¬í•˜ëŠ” Beans ë“¤ì— ëŒ€í•´ Proxy ê°€ ì ìš©ë©ë‹ˆë‹¤. Proxy ê°€ ì›ë³¸ ì»´í¬ë„ŒíŠ¸ë¥¼ ê°ì‹¸ê³  ìˆëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤. `@Transactional` ì–´ë…¸í…Œì´ì…˜ë„ ë§ˆì°¬ê°€ì§€ì˜ ì›ë¦¬ë¡œ êµ¬í˜„ ë©ë‹ˆë‹¤.

```kotlin
val proxyFactory = ProxyFactory()
proxyFactory.addInterface(TestService::class)
proxyFactory.addAdvice(advice)
proxyFactory.addAdvisor(advisor)
```

@Transactional ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ê²Œ ëœë‹¤ë©´ í•´ë‹¹ ë©”ì†Œë“œ ì‹œì‘ ì‹œ Transaction ì„ ì‹œì‘í•˜ê³ , ì„±ê³µ ì‹œ ì»¤ë°‹, ì‹¤íŒ¨ ì‹œ ë¡¤ë°±í•©ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ Runtime Exception ì´ ë°œìƒí•œë‹¤ë©´ ë¡¤ë°±í•˜ê²Œ ë©ë‹ˆë‹¤.

```kotlin
@Transactional
public void processOrder(Order order) {
    orderRepository.save(order);
    paymentService.processPayment(order);
}
```

ê°„ë‹¨í•˜ì£ ? ì´ ì–´ë…¸í…Œì´ì…˜ì„ ë‹¬ì•„ ì£¼ì§€ ì•ŠëŠ”ë‹¤ë©´ ì•ì„œ ë§ì”€ ë“œë ¸ë‹¤ì‹œí”¼ `Auto Commit` ëª¨ë“œë¡œ ì²˜ë¦¬ ë©ë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì´ êµ³ì´ í•„ìš” ì—†ë‹¤ë©´ ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ ë¬´ê´€í•©ë‹ˆë‹¤.

> ğŸ’¡ ì¢‹ì€ ê¸°ëŠ¥ì¸ ê²ƒ ê°™ì€ë°...DB ì˜ Transaction ê³¼ ì •í™•íˆ ë¬´ìŠ¨ ì°¨ì´ì¸ê°€ìš”?

Springì˜ @Transactionalì€ Physical Transaction ê³¼ Logical Transaction ë‘ ê°€ì§€ ê´€ì ì—ì„œ ì´í•´í•  í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.

| ê°œë…          | ì„¤ëª…                                                                       |
| ----------- | ------------------------------------------------------------------------ |
| **Physical Transaction** | DB Connection ë‹¨ìœ„ë¡œ ë¬¶ì´ëŠ” ì‹¤ì œ DBì™€ì˜ ì»¤ë„¥ì…˜ ê¸°ë°˜ Transaction.|
| **Logical Transaction** | Spring ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ ê´€ë¦¬ë˜ëŠ” Transaction ì˜ ë…¼ë¦¬ì  ë‹¨ìœ„. ì—¬ëŸ¬ Logical Transaction ì´ í•˜ë‚˜ì˜ Physical Transaction ì— ë§¤í•‘ë  ìˆ˜ ìˆìŒ. |

ìš°ë¦¬ê°€ í”íˆ DB ì—ì„œ ìƒê°í•˜ëŠ” ê²ƒì´ Physical Transaction, ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ ê´€ë¦¬ë˜ëŠ” ì˜ì—­ì´ Logical Transaction ì´ì£ .  
Physical Transaction ì€ JDBC ë˜ëŠ” JPA(Hibernate), MyBatis ì™€ ê°™ì€ ORM Framework ì™€ ì—°ê²° ëœ ë°ì´í„°ë² ì´ìŠ¤ ë ˆë²¨ì—ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤.

Spring ì€ DataSource ë¥¼ í†µí•´ Physical Transaction ì„ ìƒì„±í•©ë‹ˆë‹¤.

```kotlin
val connection = dataSource.connection
connection.autoCommit = false // Transactional ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•œ ê²½ìš° Auto-commit ë¹„í™œì„±í™” 
```

ì •ìƒì ìœ¼ë¡œ ë©”ì†Œë“œê°€ ì™„ë£Œë˜ë©´ commit, ì˜ˆì™¸ê°€ ë°œìƒí•œ ê²½ìš° rollback ì´ í˜¸ì¶œë©ë‹ˆë‹¤.

```kotlin
try {
    // SQL ì‹¤í–‰
    connection.commit()
} catch (e: Exception) {
    connection.rollback()
    throw e
} finally {
    connection.close()
}
```

Logical Transaction ì€ Spring Transaction ê´€ë¦¬ìê°€ ê´€ë¦¬í•©ë‹ˆë‹¤. ì—¬ëŸ¬ ì„œë¹„ìŠ¤ ë©”ì†Œë“œê°€ í•˜ë‚˜ì˜ Physical Transaction ì— í¬í•¨ë  ìˆ˜ ìˆì£ .  
ì¡°ê¸ˆ ë’¤ì—ì„œ ìì„¸íˆ ì„¤ëª… í•˜ê² ì§€ë§Œ, ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ ì´ Transaction ì´ ì–´ëŠ ë©”ì†Œë“œ ê¹Œì§€ ì „íŒŒë˜ì–´ì•¼ í•  ì§€ë¥¼ ê°œë°œìê°€ ì„¤ì •í•´ì¤„ ìˆ˜ ìˆì£ . ì´ë¥¼ ì „íŒŒ ë ˆë²¨ (Propagation Level) ì´ë¼ê³  í•©ë‹ˆë‹¤.

Spring ì€ ì´ëŸ° Logical Transaction ì„ ê´€ë¦¬í•˜ê³  í•„ìš”í•œ ê²½ìš° Physical Transaction ì— ë°˜ì˜í•©ë‹ˆë‹¤. ì•ì„œ ë§ì”€ ë“œë¦° ì „íŒŒë ˆë²¨ì— ë”°ë¼ í•˜ë‚˜ì˜ Physical Transaction ì—ëŠ” ì—¬ëŸ¬ê°œì˜ Logical Transaction ì´ ì¡´ì¬í•  ìˆ˜ ìˆì£ .

# âš™ï¸ @Transactional ì–´ë…¸í…Œì´ì…˜ì˜ ì„¤ì • ê°’

@Transactional ì–´ë…¸í…Œì´ì…˜ì€ ë„¤ ê°€ì§€ì˜ ì„¤ì • íŒŒë¼ë¯¸í„°ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.

- Propagation : íŠ¸ëœì­ì…˜ì´ ì–´ë–»ê²Œ ì „íŒŒë ì§€ë¥¼ ê²°ì • (ì˜ˆ: REQUIRED, REQUIRES_NEW)
- Isolation : íŠ¸ëœì­ì…˜ì´ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ê³¼ ì–´ë–»ê²Œ ê²©ë¦¬ë ì§€ ì„¤ì • (ì˜ˆ: READ_COMMITTED)
- RollbackFor : íŠ¹ì • ì˜ˆì™¸ì— ëŒ€í•´ ë¡¤ë°± ì—¬ë¶€ë¥¼ ì„¤ì •
- ReadOnly : íŠ¸ëœì­ì…˜ì„ ì½ê¸° ì „ìš©ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”

ì£¼ìš” ì†ì„±ë“¤ì— ëŒ€í•´ í•œë²ˆ ì§šê³  ë„˜ì–´ê°€ê² ìŠµë‹ˆë‹¤.

## ğŸ“¢ Propagation

ì•ì„œ ë§ì”€ë“œë¦° Logical Transaction ì„ ì„¤ì •í•˜ëŠ” ì˜µì…˜ì…ë‹ˆë‹¤. ë©”ì†Œë“œì˜ íë¦„ì— ë”°ë¼ ê°œë°œìê°€ ì§€ì •í•´ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

| Propagation Level | ì„¤ëª…                                                     |
| ----------------- | ------------------------------------------------------ |
| `REQUIRED`        | ì´ë¯¸ íŠ¸ëœì­ì…˜ì´ ìˆìœ¼ë©´ ì°¸ì—¬í•˜ê³ , ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„± (Default).                |
| `REQUIRES_NEW`    | ë¬´ì¡°ê±´ ìƒˆë¡œìš´ íŠ¸ëœì­ì…˜ì„ ìƒì„±. ê¸°ì¡´ íŠ¸ëœì­ì…˜ì€ ì¼ì‹œ ì¤‘ë‹¨.                      |
| `NESTED`          | ë¶€ëª¨ íŠ¸ëœì­ì…˜ì˜ ì¼ë¶€ë¡œ ë™ì‘í•˜ë˜, ê°œë³„ ì»¤ë°‹/ë¡¤ë°±ì´ ê°€ëŠ¥. (Savepointë¥¼ í†µí•´ ë¡¤ë°± ê°€ëŠ¥) |
| `SUPPORTS`        | íŠ¸ëœì­ì…˜ì´ ìˆìœ¼ë©´ ì°¸ì—¬í•˜ê³ , ì—†ìœ¼ë©´ íŠ¸ëœì­ì…˜ ì—†ì´ ì‹¤í–‰.                        |
| `NOT_SUPPORTED`   | íŠ¸ëœì­ì…˜ì´ ìˆìœ¼ë©´ ì¼ì‹œ ì¤‘ë‹¨í•˜ê³  ë¹„íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì‹¤í–‰.                          |
| `NEVER`           | íŠ¸ëœì­ì…˜ì´ ìˆìœ¼ë©´ ì˜ˆì™¸ ë°œìƒ.                                       |

ì˜ˆë¥¼ í•˜ë‚˜ ë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤. ë‘ ê°œì˜ ì„œë¹„ìŠ¤ ë©”ì†Œë“œê°€ ë§Œì•½ `REQUIRED` (ê¸°ë³¸ê°’) ë¡œ ì„ ì–¸ ëœë‹¤ë©´ ë™ì¼í•œ Physical Transaction ì„ ê³µìœ í•©ë‹ˆë‹¤.

```kotlin
@Transactional
fun methodA() {
    // ë¬¼ë¦¬ íŠ¸ëœì­ì…˜ ì‹œì‘
    repository.save(entityA) 
    methodB()
    // ì»¤ë°‹ ë˜ëŠ” ë¡¤ë°±
}

@Transactional(propagation = Propagation.REQUIRED)
fun methodB() {
    // ê°™ì€ ë¬¼ë¦¬ íŠ¸ëœì­ì…˜ ì‚¬ìš©
    repository.save(entityB)
}
```

í•˜ì§€ë§Œ `REQUIRED_NEW` ë¡œ ì„ ì–¸ ëœë‹¤ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”? ë¬´ì¡°ê±´ ë§¤ ë©”ì†Œë“œ ë§ˆë‹¤ ìƒˆë¡œìš´ Physical Transaction ìœ¼ë¡œ ë…ë¦½ë©ë‹ˆë‹¤.  

```kotlin
@Transactional
fun parentMethod() {
    orderService.placeOrder() // ê¸°ì¡´ íŠ¸ëœì­ì…˜
    paymentService.processPayment() // ìƒˆ íŠ¸ëœì­ì…˜ ì‹œì‘
}

@Transactional(propagation = Propagation.REQUIRED_NEW)
class PaymentService {
    fun processPayment() {
        // Do Something
    }
}
```

ì´ ê²½ìš° ê°ê° ë©”ì†Œë“œì—ì„œ ì˜ˆì™¸ê°€ ë°œìƒí•´ë„ ì„œë¡œ ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.  
`processPayment` ì— ì˜ˆì™¸ê°€ ë°œìƒí•´ë„ `placeOrder` ì˜ Transaction ì€ ë¡¤ë°±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì¡°ê¸ˆ ë³µì¡í•œ ì˜ˆì‹œë¥¼ í•˜ë‚˜ ë” ë³´ê² ìŠµë‹ˆë‹¤. `NESTED` ë¡œ ì„ ì–¸ ëœë‹¤ë©´ Savepoint ë¥¼ ìƒì„±í•´ì„œ ë¶€ë¶„ ë¡¤ë°±ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```kotlin
@Transactional
fun parentMethod() {
    try {
        childMethod()
    } catch (e: Exception) {
        // childMethod ë¡¤ë°±, parentMethodëŠ” ìœ ì§€
    }
}

@Transactional(propagation = Propagation.NESTED)
fun childMethod() {
    // Savepoint ìƒì„±ë¨
    repository.save(entity)
    throw RuntimeException("Rollback only child")
}
```

ë§Œì•½ `childMethod` ì—ì„œ ì˜ˆì™¸ê°€ ë°œìƒí•œë‹¤ë©´ Savepoint ê¹Œì§€ ë¡¤ë°± ë©ë‹ˆë‹¤. `parentMethod` ëŠ” ì˜í–¥ì„ ë°›ì§€ ì•Šê³  ê³„ì† ì§„í–‰í•˜ì£ .

## ğŸ”’ Isolation

Isolation level ì€ ì—¬ëŸ¬ Transaction ì´ ë™ì‹œì— ì²˜ë¦¬ë  ë•Œ ì„œë¡œ ê°„ì„­í•˜ì§€ ì•Šê³  ë…ë¦½ì„±ì„ ìœ ì§€í•˜ëŠ” ìˆ˜ì¤€ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
SQL í‘œì¤€ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë„¤ ê°€ì§€ ê²©ë¦¬ ìˆ˜ì¤€ì„ ì œê³µí•©ë‹ˆë‹¤.

| Isolation Level    | ì„¤ëª…   | ë¬¸ì œ ë°œìƒ ê°€ëŠ¥ì„±   |
| ------------------ | ----------------------------------------- | --------------------------------------------- |
| `READ_UNCOMMITTED` | ì»¤ë°‹ë˜ì§€ ì•Šì€ ë³€ê²½ ë‚´ìš©ë„ ë‹¤ë¥¸ Transaction ì´ ì½ì„ ìˆ˜ ìˆìŒ   | Dirty Read, Non-repeatable Read, Phantom Read |
| `READ_COMMITTED`   | ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ì„ ìˆ˜ ìˆìŒ. SQL Serverì˜ ê¸°ë³¸ê°’   | Non-repeatable Read, Phantom Read |
| `REPEATABLE_READ`  | ê°™ì€ Transaction ë‚´ì—ì„œëŠ” ë™ì¼í•œ ë°ì´í„°ë¥¼ ë°˜ë³µí•´ì„œ ì½ì„ ë•Œ ê°’ì´ ë³€í•˜ì§€ ì•ŠìŒ | Phantom Read |
| `SERIALIZABLE`     | Transaction ì„ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰í•˜ëŠ” ê²ƒì²˜ëŸ¼ ê²©ë¦¬. ê°€ì¥ ë†’ì€ ê²©ë¦¬ ìˆ˜ì¤€      | ì—†ìŒ (ì„±ëŠ¥ ì €í•˜ê°€ í¼) |

ì—¬ê¸°ì„œ ì •ì˜ ëœ ë¬¸ì œë“¤ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³¼ê²Œìš”.  

- Dirty Read
  - ë‹¤ë¥¸ Transaction ì»¤ë°‹í•˜ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  - Transactionì´ ë¡¤ë°±ë˜ë©´ ì½ì€ ë°ì´í„°ëŠ” ë¬´íš¨í•œ ë°ì´í„°ê°€ ë©ë‹ˆë‹¤.

- Non-repeatable Read
  - ê°™ì€ Transaction ë‚´ì—ì„œ ë‘ ë²ˆ ì¡°íšŒ ì‹œ ê°’ì´ ë‹¤ë¥´ê²Œ ë³´ì…ë‹ˆë‹¤.
  - ë‹¤ë¥¸ Transaction ì´ ì»¤ë°‹í•˜ë©´ ë³€ê²½ëœ ê°’ì´ ë°˜ì˜ë©ë‹ˆë‹¤.

- Phantom Read
  - ê°™ì€ Transaction ë‚´ì—ì„œ ë²”ìœ„ ì¿¼ë¦¬ì˜ ê²°ê³¼ê°€ ë‹¤ë¥´ê²Œ ë³´ì…ë‹ˆë‹¤.
  - ë‹¤ë¥¸ Transaction ì´ ì»¤ë°‹í•˜ë©´ì„œ ìƒˆë¡œìš´ ë°ì´í„°ê°€ ì¶”ê°€ë˜ê±°ë‚˜ ì‚­ì œë©ë‹ˆë‹¤.

@Transactional ì–´ë…¸í…Œì´ì…˜ì—ì„œ ì´ ì†ì„±ì„ ì¡°ì •í•´ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìì„¸íˆ ì•Œì•„ë³¼ê¹Œìš”?
ì•ì„œ ì„¤ëª…ë“œë¦° ë„¤ ê°€ì§€ ì˜µì…˜ ì™¸ì— Default ì˜µì…˜ì´ ì¡´ì¬í•©ë‹ˆë‹¤.

- `DEFAULT` : DBMSì˜ ê¸°ë³¸ Isolation Levelì„ ë”°ë¦„. ë³´í†µ **READ\_COMMITTED** ë˜ëŠ” **REPEATABLE\_READ**
- `READ_UNCOMMITTED` : ì»¤ë°‹ë˜ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìˆìŒ. Dirty Readê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ
- `READ_COMMITTED` : ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ì„ ìˆ˜ ìˆìŒ. SQL Serverì˜ ê¸°ë³¸ê°’
- `REPEATABLE_READ` : Transaction ë‚´ì—ì„œ ë™ì¼ ë°ì´í„°ë¥¼ ë°˜ë³µí•´ì„œ ì½ìœ¼ë©´ í•­ìƒ ê°™ì€ ê°’ì´ ë³´ì„  
- `SERIALIZABLE` : Transaction ì´ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒì²˜ëŸ¼ ë™ì‘. ë™ì‹œì„± ì„±ëŠ¥ì´ ë–¨ì–´ì§

### DEFAULT

ë³„ë„ë¡œ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ Default ì†ì„±ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤.

```kotlin
@Transactional(isolation = Isolation.DEFAULT)
fun defaultIsolationExample() {
    val account = accountRepository.findById(1L).get()
    account.balance -= 100
    accountRepository.save(account)
}
```

ë³„ë„ë¡œ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ DBì˜ ê¸°ë³¸ ê²©ë¦¬ ìˆ˜ì¤€ì´ ì ìš©ë©ë‹ˆë‹¤.  
MySQLì—ì„œëŠ” REPEATABLE_READ, PostgreSQLì—ì„œëŠ” READ_COMMITTEDë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.  
ë™ì‹œì„± ì œì–´ëŠ” DBMS ì„¤ì •ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤.

### READ_UNCOMMITED

READ_UNCOMMITED ëŠ” ì•ì„œ ì„¤ëª…ê³¼ ê°™ì´ ì»¤ë°‹ë˜ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ë‹¤ë¥¸ Transaction ì´ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. Dirty Read ê°€ ë°œìƒí•  ìˆ˜ ìˆì£ .

```kotlin
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
fun readUncommittedExample() {
    val balance = accountRepository.findBalanceById(1L)
    println("Balance: $balance")
}
```

ë§Œì•½ Transaction A ì—ì„œ ê°’ì„ ë³€ê²½í–ˆë‹¤ê³  ê°€ì • í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì»¤ë°‹ì„ í•˜ì§€ ì•Šì€ ìƒíƒœì…ë‹ˆë‹¤.

```sql
-- Transaction A
BEGIN;
UPDATE accounts SET balance = 1000 WHERE id = 1;
```

Transaction B ì—ì„œ ì½ê¸° ì¿¼ë¦¬ê°€ ë‚ ì•„ê°”ìŠµë‹ˆë‹¤.

```sql
-- Transaction B
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT balance FROM accounts WHERE id = 1; 
-- ğŸ’¡ 1000ì´ ë³´ì„ (Dirty Read)
```

ì ë­”ê°€ ì˜ëª»ë˜ì—ˆë„¤ìš”. Transaction A ì—ì„œ ë¡¤ë°±ì²˜ë¦¬ë¥¼ í–ˆìŠµë‹ˆë‹¤.

```sql
-- Transaction A
ROLLBACK;
```

ì´ ê²½ìš° Transaction B ëŠ” ì»¤ë°‹ë˜ì§€ ì•Šì€ 1000ì„ ì½ì—ˆì£ ? ì´ Transaction ì„ ì‚¬ìš©í•œ ë¡œì§ì€ Dirty Read ë¡œ ì¸í•´ ë°ì´í„° ì¼ê´€ì„±ì´ ê¹¨ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### READ_COMMITTED

READ_COMMITTED ëŠ” ì»¤ë°‹ ëœ ê°’ë§Œ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. Non repeatable Read ê°€ ë°œìƒí•  ìˆ˜ ìˆê³ , PostgreSQL, Oracle ì˜ ê¸°ë³¸ ê°’ì…ë‹ˆë‹¤.

```kotlin
@Transactional(isolation = Isolation.READ_COMMITTED)
fun readCommittedExample() {
    val balance = accountRepository.findBalanceById(1L)
    println("Balance: $balance")
}
```

ë§ˆì°¬ê°€ì§€ë¡œ ì˜ˆì‹œë¥¼ ë³¼ê²Œìš”. Transaction A ì—ì„œ ê°’ì„ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.

```sql
-- Transaction A
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- ğŸ’¡ 500
```

ê·¸ í›„ Transaction B ì—ì„œ ê°’ ìˆ˜ì • í›„ ì»¤ë°‹ì´ ì¼ì–´ë‚¬ìŠµë‹ˆë‹¤.

```sql
-- Transaction B
BEGIN;
UPDATE accounts SET balance = 700 WHERE id = 1;
COMMIT;
```

Transaction A ì—ì„œ ê°’ì„ ë‹¤ì‹œ ì¡°íšŒí•˜ë‹ˆ ê°’ì´ ë³€ê²½ ë˜ì—ˆë„¤ìš”? Non repeatable Read ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.

```sql
-- Transaction A
SELECT balance FROM accounts WHERE id = 1; -- ğŸ’¡ 700 (ê°’ì´ ë³€ê²½ë¨, Non-repeatable Read)
COMMIT;
```

### REPEATABLE_READ

ê°™ì€ Transaction ë‚´ì—ì„œëŠ” ë°˜ë³µ ì¡°íšŒ ì‹œ ë™ì¼í•œ ê°’ì´ ë³´ì…ë‹ˆë‹¤. MySQL ì˜ ê¸°ë³¸ ê²©ë¦¬ ìˆ˜ì¤€ì´ì£ . ì´ ê²½ìš° Phantom Read ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```kotlin
@Transactional(isolation = Isolation.REPEATABLE_READ)
fun repeatableReadExample() {
    val balance1 = accountRepository.findBalanceById(1L)
    println("First Read: $balance1")

    // ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì´ ê°’ì„ ë³€ê²½í•´ë„ ë³´ì´ì§€ ì•ŠìŒ
    val balance2 = accountRepository.findBalanceById(1L)
    println("Second Read: $balance2")
}
```

Transaction A ì—ì„œ ê°’ì„ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.

```sql
-- Transaction A
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- ğŸ’¡ 500
```

Transaction B ì—ì„œ ê°’ì„ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.

```sql
-- Transaction B
BEGIN;
UPDATE accounts SET balance = 800 WHERE id = 1;
COMMIT;
```

Transaction A ì—ì„œ ë‹¤ì‹œ ê°’ì„ ì¡°íšŒí•˜ë‹ˆ ê°’ì´ ê·¸ëŒ€ë¡œ ì…ë‹ˆë‹¤.

```sql
-- Transaction A
SELECT balance FROM accounts WHERE id = 1; -- ğŸ’¡ 500 (ë³€ê²½ëœ ê°’ì´ ë³´ì´ì§€ ì•ŠìŒ)
COMMIT;
```

### SERIALIZABLE

ë§ˆì§€ë§‰ìœ¼ë¡œ Serializable ì…ë‹ˆë‹¤. ëª¨ë“  Transaction ì´ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒ ì²˜ëŸ¼ ë™ì‘í•˜ì£ . ì´ ê²½ìš° Phantom Read ê°€ ë°œìƒí•˜ì§€ëŠ” ì•Šì§€ë§Œ, ê°€ì¥ ì„±ëŠ¥ì´ ë‚®ì£ .

```kotlin
@Transactional(isolation = Isolation.SERIALIZABLE)
fun serializableExample() {
    val accounts = accountRepository.findAll()
    println("Accounts: $accounts")
}
```

Transaction A ì—ì„œ ê°’ì„ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.

```sql
-- Transaction A
BEGIN;
SELECT * FROM accounts WHERE balance > 500;
```

Transaction B ê°€ ê°’ ë³€ê²½ì„ ì‹œë„ í–ˆìŠµë‹ˆë‹¤. ì´ ê²½ìš° Block ì´ ê±¸ë¦½ë‹ˆë‹¤.

```sql
-- Transaction B
BEGIN;
INSERT INTO accounts (id, balance) VALUES (10, 600); -- ğŸš« Blocked!
```

Transaction A ê°€ ì»¤ë°‹ë˜ê¸° ì „ ê¹Œì§€ Transaction B ê°€ ëŒ€ê¸°í•˜ê²Œ ë©ë‹ˆë‹¤.

### ì •ë¦¬

| Isolation Level    | Dirty Read | Non-repeatable Read | Phantom Read | ì„±ëŠ¥        |
| ------------------ | ---------- | ------------------- | ------------ | --------- |
| `DEFAULT`          | DB ì„¤ì •ì— ë”°ë¦„  | DB ì„¤ì •ì— ë”°ë¦„           | DB ì„¤ì •ì— ë”°ë¦„    | DB ì„¤ì •ì— ë”°ë¦„ |
| `READ_UNCOMMITTED` | âœ…          | âœ…                   | âœ…            | ğŸ‘ğŸ‘ğŸ‘ğŸ‘  |
| `READ_COMMITTED`   | âŒ          | âœ…                   | âœ…            | ğŸ‘ğŸ‘ğŸ‘    |
| `REPEATABLE_READ`  | âŒ          | âŒ                   | âœ…            | ğŸ‘ğŸ‘      |
| `SERIALIZABLE`     | âŒ          | âŒ                   | âŒ            | ğŸ‘        |

MySQL, PostgreSQL, Oracle, SQL Server ë“± ê°ê°ì˜ DBMS ì— ë”°ë¼ ê¸°ë³¸ ê°’ Isolation Level ì€ ë‹¤ë¦…ë‹ˆë‹¤. ë¡œì§ì˜ ì„±ê²©ì— ë”°ë¼ ë‹¤ë¥´ê² ì§€ë§Œ, ê°œì¸ì ìœ¼ë¡  ìœ ì € í•œëª…ì—ê²Œ 1ëŒ€1ë¡œ í• ë‹¹ ë˜ëŠ” ë°ì´í„°ë¼ë©´ `REPEATABLE_READ` ë¥¼ ì¨ë„ ê´œì°®ì§€ ì•Šë‚˜ ë¼ëŠ” ìƒê°ì„ í•©ë‹ˆë‹¤.  
ë°°ì¹˜ ë¡œì§ ë“±ì„ ì‘ì„±í•  ë•ŒëŠ” Isolation Level ì— ë”°ë¥¸ ì—ëŸ¬ ë°œìƒì„ ë§‰ê¸° ìœ„í•´ ë”ì´ìƒ Update ë˜ì§€ ì•Šì„ ë²• í•œ ë°ì´í„°ë¥¼ ìµœëŒ€í•œ ì½ëŠ” ì „ëµì„ ì‚¬ìš©í•˜ê³¤ í•©ë‹ˆë‹¤.

## âª RollbackFor

@Transactional ì€ ê¸°ë³¸ì ìœ¼ë¡œ ì•„ë˜ì™€ ê°™ì€ ê·œì¹™ì„ ë”°ë¦…ë‹ˆë‹¤.

| Exception ìœ í˜•            | ê¸°ë³¸ ë™ì‘ | ì„¤ëª…     |
| ----------------------- | ----- | -------------------------------------------------------- |
| **Unchecked Exception** | ë¡¤ë°±    | `RuntimeException`, `IllegalArgumentException` ë“± ë°œìƒ ì‹œ ë¡¤ë°± |
| **Checked Exception**   | ì»¤ë°‹    | `Exception`, `IOException` ë“± ë°œìƒ ì‹œ ì»¤ë°‹ ì§„í–‰   |
| **Error**               | ë¡¤ë°± ì•ˆë¨ | ì‹œìŠ¤í…œ ì—ëŸ¬ (`OutOfMemoryError`)ëŠ” ë¡¤ë°±ë˜ì§€ ì•ŠìŒ    |

> ğŸ’¡ì—¬ê¸°ì„œ ì ê¹! Unchecked / Checked Exception ì˜ ì°¨ì´ê°€ ë­”ê°€ìš”?  
> ì»´íŒŒì¼ëŸ¬ê°€ ì˜ˆì™¸ ì²˜ë¦¬ ì—¬ë¶€ë¥¼ ê²€ì‚¬í•˜ëŠ” ì§€ ì—¬ë¶€ì— ë”°ë¼ ë‚˜ë‰©ë‹ˆë‹¤.
> Unchecked Exceptoin ì€ ëŒ€í‘œì ìœ¼ë¡œ `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArthmeticException`ì´ ìˆê³ , Checked Exception ì€ `IOException`, `SQLException`, `ClassNotFoundException` ì´ ìˆìŠµë‹ˆë‹¤.  
> ì†Œí”„íŠ¸ì›¨ì–´ì˜ ì•ˆì •ì„±ì— ë”°ë¼ ë‚˜ë‰©ë‹ˆë‹¤. Unchecked Exception ì€ ë³´í†µì€ í”„ë¡œê·¸ë˜ë¨¸ì˜ ì‹¤ìˆ˜ì— ì˜í•´ ë§ì´ ë°œìƒí•˜ì£ .

RollbackFor ì˜µì…˜ì€ ëª…ì‹œì ìœ¼ë¡œ íŠ¹ì •í•œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ëŠ” ê²½ìš° ë¡¤ë°±í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤.

```kotlin
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.io.IOException
import java.sql.SQLException

@Service
class PaymentService(private val paymentRepository: PaymentRepository) {

    @Transactional(rollbackFor = [IOException::class, SQLException::class])
    fun processMultipleExceptions(payment: Payment) {
        paymentRepository.save(payment)
        
        if (payment.amount > 1000) {
            throw IOException("Amount exceeded limit")
        } else {
            throw SQLException("Database error occurred")
        }
    }
}
```

rollbackFor ì˜µì…˜ì„ í†µí•´ Checked Exception ë˜í•œ ë¡¤ë°± ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¢€ ë” ì‘ìš©í•´ì„œ ì—¬ëŸ¬ ì˜ˆì™¸ì— ëŒ€í•´ ë¡¤ë°± ì²˜ë¦¬ë¥¼ í•  ìˆ˜ë„ ìˆì£ .

ë°˜ëŒ€ë¡œ noRollbackFor ì˜µì…˜ë„ ìˆìŠµë‹ˆë‹¤. íŠ¹ì • ì˜ˆì™¸ê°€ ë°œìƒí•˜ë”ë¼ë„ ë¡¤ë°±í•˜ì§€ ì•Šë„ë¡ ì„¤ì •í•  ìˆ˜ ìˆì£ .

```kotlin
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.io.IOException

@Service
class PaymentService(private val paymentRepository: PaymentRepository) {

    @Transactional(noRollbackFor = [IOException::class])
    fun processWithNoRollback(payment: Payment) {
        paymentRepository.save(payment)
        throw IOException("Checked Exception ë°œìƒ") // ğŸ’¡ ë¡¤ë°±ë˜ì§€ ì•ŠìŒ
    }
}
```

## ğŸ“– ReadOnly

@Transactionalì—ì„œ ì œê³µí•˜ëŠ” readOnly ì˜µì…˜ì€ í•´ë‹¹ íŠ¸ëœì­ì…˜ì´ ì˜¤ì§ ì½ê¸° ì „ìš© ì‘ì—…ë§Œ ìˆ˜í–‰í•  ê²ƒì„ ëª…ì‹œí•©ë‹ˆë‹¤.

SQL SELECT ë¬¸ê³¼ ê°™ì€ ì½ê¸° ì‘ì—…ë§Œ ìˆ˜í–‰í•  ë•Œ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  JPA, Hibernateì™€ ê°™ì€ ORMì—ì„œ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ë¥¼ Dirty Checking (ë³€ê²½ ê°ì§€) í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.ê·¸ë˜ì„œ ë°ì´í„° ìˆ˜ì •ì´ ë°œìƒí•  ê²½ìš° ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```kotlin
@Transactional(readOnly = true)
fun findUserById(id: Long): User {
    return userRepository.findById(id).orElseThrow()
}
```

ì´ ê²½ìš° JPA ëŠ” ì—”í‹°í‹° ë³€ê²½ì„ ê°ì§€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ Flush ì‘ì—…ì„ í•˜ì§€ ì•Šì•„ìš”.

ë§Œì•½ ReadOnly ê°€ í™œì„±í™”ë˜ë©´ Hibernate ì„¸ì…˜ì´ `FlushMode.MANUAL` ë¡œ ì„¤ì •ë©ë‹ˆë‹¤. ê¸°ë³¸ê°’ì€ `FlushMode.AUTO` ì£ . ì•ì„œ ë§ì”€ë“œë ¸ë‹¤ì‹œí”¼ Dirty Checking ì´ ì´ë¤„ì§€ì§€ ì•Šê³  DB ì— UPDATE, INSERT ê°€ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```kotlin
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UserService(private val userRepository: UserRepository) {

    @Transactional(readOnly = true)
    fun updateUserEmail(userId: Long, newEmail: String) {
        val user = userRepository.findById(userId).orElseThrow()
        user.email = newEmail
        userRepository.save(user) // ğŸ’¡ ì˜ˆì™¸ ë°œìƒ ê°€ëŠ¥ì„±
    }
}
```

í•œë²ˆ readOnly ì˜µì…˜ì„ ê±¸ì–´ë†“ê³  save ë¥¼ ì‹œë„ í•´ ë³¼ê¹Œìš”?

```shell
org.springframework.transaction.TransactionSystemException:
Could not commit JPA transaction; nested exception is javax.persistence.TransactionRequiredException
```

ë‹¹ì—°íˆ DBì— ë°˜ì˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Hibernate ê°€ flush í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ì£ . ê°•ì œë¡œ ë³€ê²½ì„ ê°ì§€í•˜ë ¤ê³  í•˜ë©´ ì˜ˆì™¸ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ ì˜µì…˜ì„ ì¢€ ë” ì‘ìš©í•˜ë©´, Spring Data JPA ì—ì„œ Repository ë©”ì†Œë“œì— ê°œë³„ì ìœ¼ë¡œ ì§€ì •í•´ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```kotlin
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.CrudRepository
import org.springframework.transaction.annotation.Transactional

interface UserRepository : CrudRepository<User, Long> {

    @Transactional(readOnly = true)
    @Query("SELECT u FROM User u WHERE u.email = :email")
    fun findByEmail(email: String): User?
}
```

@Queryì™€ @Transactional(readOnly = true)ë¥¼ ê²°í•©í•˜ë©´ ì½ê¸° ì „ìš© íŠ¸ëœì­ì…˜ì´ ì ìš©ë©ë‹ˆë‹¤. ì´ ê²½ìš° í”ŒëŸ¬ì‹œê°€ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

í•´ë‹¹ ì˜µì…˜ì„ ì‚¬ìš©í•˜ë©´ ì„±ëŠ¥ ìµœì í™”ì— ì´ì ì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ìœ ëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.

- Dirty Checkingì„ ìƒëµ
  - Hibernateê°€ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ì˜ ì—”í‹°í‹° ë³€ê²½ ì—¬ë¶€ë¥¼ ê°ì§€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  - ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¤„ì–´ë“¤ê³  ì²˜ë¦¬ ì†ë„ê°€ ë¹¨ë¼ì§‘ë‹ˆë‹¤.

- Flushë¥¼ ìƒëµ
  - FlushMode.MANUALë¡œ ì„¤ì •ë˜ì–´ DBì— ì—…ë°ì´íŠ¸ ì‹œë„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  - ë„¤íŠ¸ì›Œí¬ ì˜¤ë²„í—¤ë“œê°€ ê°ì†Œí•©ë‹ˆë‹¤.

- MySQLì—ì„œ ìµœì í™”
  - MySQL 8.0 ì´ìƒì—ì„œëŠ” ì½ê¸° ì „ìš© íŠ¸ëœì­ì…˜ì— ëŒ€í•œ ìµœì í™”ê°€ ìë™ìœ¼ë¡œ ì ìš©ë©ë‹ˆë‹¤.

# ğŸ˜­ @Transaction ì´ ì—†ìœ¼ë©´ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œ

ì •ë§ ê°„ë‹¨í•œ Read ì˜ ê²½ìš°ëŠ” ë¶ˆ í•„ìš” í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë¬¼ë¡  í•„ìš”í•œ ê²½ìš°ë„ ì¡´ì¬í•©ë‹ˆë‹¤. ë§Œì•½ ìš°ë¦¬ê°€ ReadOnly Database ë¥¼ ë¶„ë¦¬í–ˆë‹¤ë©´ í•„ìš”í•  ìˆ˜ ìˆì£ . (ìì„¸í•œ ì‚¬ìš©ë²•ì€ ì‘ìš© íŒŒíŠ¸ì—ì„œ ì„œìˆ í•©ë‹ˆë‹¤.)

í•˜ì§€ë§Œ `Create`, `Update`, `Delete` ì˜ ê²½ìš°ì—ëŠ” ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ì ê·¹ ê¶Œì¥í•©ë‹ˆë‹¤. ì‚¬ìœ ëŠ” ì•„ë˜ ë•Œë¬¸ì…ë‹ˆë‹¤.

- Partial Update
  - ì—¬ëŸ¬ SQLì´ ì‹¤í–‰ ì¤‘ í•˜ë‚˜ê°€ ì‹¤íŒ¨í•˜ë©´ ì´ì „ì— ì‹¤í–‰ëœ SQLì€ ë¡¤ë°±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  - ì˜ˆë¥¼ ë“¤ì–´, A, B ë‘ í…Œì´ë¸”ì´ ì—…ë°ì´íŠ¸ë˜ëŠ”ë°, Bì—ì„œ ì˜ˆì™¸ ë°œìƒ ì‹œ Aì˜ ë³€ê²½ ì‚¬í•­ì€ ë°˜ì˜ëœ ìƒíƒœë¡œ ë‚¨ìŠµë‹ˆë‹¤.

- Dirty Read, Non-repeatable Read, Phantom Read
  - Isolation Level ì„¤ì •ì´ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ, ì½ê¸° ì¤‘ê°„ì— ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì´ ë³€ê²½í•œ ê°’ì„ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  - ë°˜ë³µ ì½ê¸° ì‹œ ê°’ì´ ë‹¬ë¼ì§€ê±°ë‚˜, ì»¤ë°‹ë˜ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  
- Rollback ë¶ˆê°€
  - @Transactionalì´ ì—†ìœ¼ë©´ Checked Exception ë°œìƒ ì‹œ ë¡¤ë°±ì´ ìë™ìœ¼ë¡œ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  - ì§ì ‘ rollback()ì„ í˜¸ì¶œí•˜ì§€ ì•Šìœ¼ë©´ DBì—ëŠ” ë³€ê²½ ì‚¬í•­ì´ ë‚¨ìŠµë‹ˆë‹¤.

# ğŸ’¡ ì‘ìš© : Spring @Transactional í…ŒìŠ¤íŠ¸ - Physical Transaction ë¶„ë¦¬ ê²€ì¦

ê°„ë‹¨í•œ ì˜ˆì‹œë¥¼ í•˜ë‚˜ ë³´ê² ìŠµë‹ˆë‹¤. ì‹¤ì œ ë¡œì§ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œ Transaction ì´ ì •ìƒì ìœ¼ë¡œ ë¡¤ë°±ë˜ëŠ” ì§€ í™•ì¸í•˜ëŠ” ì˜ˆì‹œë“¤ì„ ì‘ì„± í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```kotlin
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.throwables.shouldThrow
import io.mockk.*
import jakarta.transaction.Transactional
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.mock.mockito.MockBean

@SpringBootTest
@Transactional
class OrderServiceTest @Autowired constructor(
    private val orderRepository: OrderRepository
) : DescribeSpec({

    // OrderServiceë¥¼ Spyë¡œ ìƒì„± (ì‹¤ì œ ë©”ì„œë“œëŠ” ì‹¤í–‰í•˜ë˜ ì¼ë¶€ëŠ” Mock)
    val orderService = spyk(OrderService(orderRepository))

    describe("OrderService - íŠ¸ëœì­ì…˜ ë¡¤ë°± í…ŒìŠ¤íŠ¸") {

        context("Order ìƒì„± ì‹œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ë©´") {

            val order = Order(description = "Test Order")
            val initialCount = orderRepository.count()

            // Mocking: save() í˜¸ì¶œ ì‹œ ì˜ˆì™¸ ë°œìƒí•˜ë„ë¡ ì„¤ì •
            every { orderRepository.save(any()) } throws RuntimeException("DB Error")

            it("íŠ¸ëœì­ì…˜ì´ ë¡¤ë°±ë˜ì–´ ê°œìˆ˜ê°€ ì¦ê°€í•˜ì§€ ì•ŠëŠ”ë‹¤") {
                shouldThrow<RuntimeException> {
                    orderService.createOrder(order)
                }

                val finalCount = orderRepository.count()
                finalCount shouldBe initialCount // ë¡¤ë°±ë˜ì—ˆìœ¼ë¯€ë¡œ ë™ì¼í•´ì•¼ í•¨
            }

            it("save() ë©”ì„œë“œëŠ” í•œ ë²ˆë§Œ í˜¸ì¶œëœë‹¤") {
                verify(exactly = 1) { orderRepository.save(any()) }
            }

            afterEach {
                // MockK ìƒíƒœ ì´ˆê¸°í™”
                clearMocks(orderRepository)
            }
        }
    }
})

```

ì¼ë¶€ëŸ¬ Exceptionì„ ë°œìƒì‹œí‚¤ëŠ” ì˜ˆì‹œì…ë‹ˆë‹¤. ì¼ë°˜ì ì¸ Transaction í…ŒìŠ¤íŠ¸ì˜ ê²½ìš° ì´ë ‡ê²Œ ê°„ë‹¨íˆ í…ŒìŠ¤íŠ¸í•´ë³¼ ìˆ˜ ìˆì£ . `mockK` ë¥¼ í™œìš©í•´ì„œ ëŒ€ìƒ ë©”ì†Œë“œì—ì„œ ì˜ˆì™¸ë¥¼ ë˜ì§€ë„ë¡ spy ì²˜ë¦¬ë¥¼ í•œ í›„ ë¡¤ë°±ë˜ëŠ” ê³¼ì •ì„ í™•ì¸ í•˜ëŠ” ì½”ë“œì…ë‹ˆë‹¤.

ì¢€ ë” ì‘ìš©í•´ì„œ `REQUIRES_NEW` ë¥¼ í˜¸ì¶œí•˜ëŠ” ì¼€ì´ìŠ¤ë¥¼ í…ŒìŠ¤íŠ¸ í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```kotlin
@Service
class OrderService(
    private val orderRepository: OrderRepository,
    private val logService: LogService
) {

    @Transactional
    fun placeOrderWithLog(order: Order) {
        orderRepository.save(order)
        
        // Propagation.REQUIRES_NEWë¡œ ë³„ë„ì˜ íŠ¸ëœì­ì…˜ì—ì„œ ì²˜ë¦¬ë¨
        logService.saveLog("Order ${order.description} created")
    }
}

@Service
class LogService(private val logRepository: LogRepository) {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    fun saveLog(message: String) {
        val log = OrderLog(message = message)
        logRepository.save(log)
    }
}
```

ì˜ˆë¥¼ ë“¤ì–´, ì£¼ë¬¸ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ì¼€ì´ìŠ¤ì—ì„œ ì˜ˆì™¸ê°€ ë°œìƒí–ˆë‹¤ê³  ê°€ì • í•´ ë³´ê² ìŠµë‹ˆë‹¤. ë¡œê·¸ì„± ë°ì´í„°ë¥¼ í•¨ê»˜ ì ì¬í•´ì•¼í•˜ëŠ” ìƒí™©ì—ì„œ ë¡œê¹… Transaction ê¹Œì§€ ë¡¤ë°±ì˜ ë²”ìœ„ì— ë“¤ì–´ê°€ì„œëŠ” ì•ˆë˜ê² ì£ ? ì´ëŸ° ì¼€ì´ìŠ¤ì—ì„œ REQUIRED_NEW ë¥¼ ë§ì´ ì‚¬ìš©í•©ë‹ˆë‹¤.

```kotlin
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.*
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest
import org.springframework.test.context.TestPropertySource

@DataJpaTest
@TestPropertySource(locations = ["classpath:application-test.properties"])
class OrderServiceLogTest @Autowired constructor(
    private val orderRepository: OrderRepository,
    private val logRepository: LogRepository
) : DescribeSpec({

    // MockKë¥¼ ì´ìš©í•˜ì—¬ LogServiceë¥¼ Spyë¡œ ìƒì„±
    val logService = spyk(LogService(logRepository))
    val orderService = OrderService(orderRepository, logService)

    describe("Propagation.REQUIRES_NEW í…ŒìŠ¤íŠ¸") {

        context("ë©”ì¸ íŠ¸ëœì­ì…˜ì´ ë¡¤ë°±ë˜ë”ë¼ë„ REQUIRES_NEW ë¡œê·¸ëŠ” DBì— ë‚¨ëŠ”ë‹¤") {

            it("ë©”ì¸ íŠ¸ëœì­ì…˜ì€ ì •ìƒ ì²˜ë¦¬ë˜ì§€ë§Œ íŠ¹ì • ì¡°ê±´ì—ì„œ ì—ëŸ¬ ë¡œê·¸ë§Œ ë‚¨ëŠ”ë‹¤") {
                // Given
                val initialLogCount = logRepository.count()
                
                // Spy ì„¤ì •: íŠ¹ì • ì¡°ê±´ì¼ ë•Œë§Œ ì˜ˆì™¸ì²˜ëŸ¼ ë™ì‘í•˜ë„ë¡ ì„¤ì •
                every { logService.saveLog(match { it.contains("fail") }) } answers {
                    println("ğŸ’¡ Mocked Failure Log: $it")
                    val log = OrderLog(message = "Failed to process: $it")
                    logRepository.save(log)
                }

                // When
                orderService.placeOrderWithLog(Order(description = "fail-order"))

                // Then
                val finalLogCount = logRepository.count()
                finalLogCount shouldBe initialLogCount + 1

                // Verify: saveLogê°€ í•œ ë²ˆë§Œ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ ê²€ì¦
                verify(exactly = 1) { logService.saveLog("Order fail-order created") }
            }

            afterEach {
                // MockK ì´ˆê¸°í™”
                clearMocks(logService)
            }
        }
    }
})
```

ì´ ê²½ìš°ì—” ë‘ ì¼€ì´ìŠ¤ë¥¼ ëª¨ë‘ ê²€ì¦í•´ì•¼ í•©ë‹ˆë‹¤. í•˜ë‚˜ì˜ Transaction ì´ ì‹¤íŒ¨í•´ë„ ë‚˜ë¨¸ì§€ ë‹¤ë¥¸ Transaction ì´ ì„±ê³µí–ˆëŠ” ì§€ë¥¼ ê²€ì¦í•´ì•¼ í•©ë‹ˆë‹¤.

# ğŸ’¡ ì‘ìš© : @Transactional ReadOnly ë¥¼ í™œìš©í•œ Read/Write DB ë¶„ë¦¬

ì‹œìŠ¤í…œì˜ ê·œëª¨ê°€ ì»¤ì§„ë‹¤ë©´ Read / Write ë¶€í•˜ë¥¼ ë¶„ì‚°í•˜ê¸° ìœ„í•´ Read Replica (ì½ê¸° ì „ìš© DB), Write DB (ì“°ê¸° ì „ìš© DB) ì„ í”íˆ ë‚˜ëˆ ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤. Read ì—ì„œëŠ” SELECT, Write ì—ì„œëŠ” INSERT, UPDATE, DELETE ë¥¼ ë‹´ë‹¹í•˜ì£ .

@Transaction ì˜ readOnly ì˜µì…˜ì— ë”°ë¼ Transaction ì„ Read Replica ì— ì „ë‹¬ í• ê²ƒì¸ì§€ ì„ íƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```yaml
spring:
  datasource:
    master:
      url: jdbc:mysql://localhost:3306/master_db
      username: root
      password: password
      driver-class-name: com.mysql.cj.jdbc.Driver

    replica:
      url: jdbc:mysql://localhost:3306/replica_db
      username: root
      password: password
      driver-class-name: com.mysql.cj.jdbc.Driver
```

ì˜ˆë¥¼ ë“¤ì–´ì„œ spring datasource ì˜µì…˜ì„ ì´ë ‡ê²Œ ë‘ ê°€ì§€ë¡œ ë‚˜ëˆ„ì—ˆë‹¤ê³  ê°€ì • í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```kotlin
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.boot.jdbc.DataSourceBuilder
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource
import javax.sql.DataSource

enum class DataSourceType {
    MASTER, REPLICA
}

object DataSourceContextHolder {
    private val contextHolder = ThreadLocal<DataSourceType>()

    fun set(dataSourceType: DataSourceType) {
        contextHolder.set(dataSourceType)
    }

    fun get(): DataSourceType {
        return contextHolder.get() ?: DataSourceType.MASTER
    }

    fun clear() {
        contextHolder.remove()
    }
}

@Configuration
class DataSourceConfig {

    @Bean
    @Qualifier("masterDataSource")
    fun masterDataSource(): DataSource {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://localhost:3306/master_db")
            .username("root")
            .password("password")
            .driverClassName("com.mysql.cj.jdbc.Driver")
            .build()
    }

    @Bean
    @Qualifier("replicaDataSource")
    fun replicaDataSource(): DataSource {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://localhost:3306/replica_db")
            .username("root")
            .password("password")
            .driverClassName("com.mysql.cj.jdbc.Driver")
            .build()
    }

    @Bean
    fun routingDataSource(
        @Qualifier("masterDataSource") masterDataSource: DataSource,
        @Qualifier("replicaDataSource") replicaDataSource: DataSource
    ): DataSource {
        val targetDataSources: MutableMap<Any, Any> = HashMap()
        targetDataSources[DataSourceType.MASTER] = masterDataSource
        targetDataSources[DataSourceType.REPLICA] = replicaDataSource

        val routingDataSource = object : AbstractRoutingDataSource() {
            override fun determineCurrentLookupKey(): Any {
                return DataSourceContextHolder.get()
            }
        }
        routingDataSource.setTargetDataSources(targetDataSources)
        routingDataSource.setDefaultTargetDataSource(masterDataSource)
        return routingDataSource
    }
}
```

ì´ì œ DataSource ì˜µì…˜ì„ ì§€ì • í•´ ì£¼ì–´ì•¼ì£ ? ë‘ DataSourceì— ëŒ€í•´ ê°ê°ì˜ @Bean ì„ ìƒì„±í•´ì¤€ í›„ routingDataSource Bean ì—ì„œ ë‘ Bean ì„ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì§€ì •í•©ë‹ˆë‹¤.

DataSourceContextHolder ëŠ” Enum ê°’ì— ë”°ë¼ DataSource ë¥¼ ì§€ì •í•˜ë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤. Kotlin ì—ì„œ object í´ë˜ìŠ¤ëŠ” Singleton ì„ì„ ë³´ì¥í•´ì£¼ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤. *Spring IOC Container ì˜ ê´€ë¦¬ê°€ êµ³ì´ í•„ìš”ì—†ëŠ” Singleton ì´ í•„ìš”í•œ ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤.*

```kotlin
import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional

@Aspect
@Component
class DataSourceRoutingAspect {

    @Before("@annotation(transactional) && execution(* com.example..*(..))")
    fun setDataSource(transactional: Transactional) {
        if (transactional.readOnly) {
            DataSourceContextHolder.set(DataSourceType.REPLICA)
        } else {
            DataSourceContextHolder.set(DataSourceType.MASTER)
        }
    }
}
```

AOP ë¥¼ í†µí•´ @Transactional ì–´ë…¸í…Œì´ì…˜ì˜ ì˜µì…˜ì— ë”°ë¼ DataSourceContextHolder ì˜ DataSourceType ì„ ë°”ê¿”ì¤ë‹ˆë‹¤.

```kotlin
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UserService(private val userRepository: UserRepository) {

    private log = getLogger()

    @Transactional(readOnly = true)
    fun getUser(email: String): User {
        // ğŸ’¡ Replica DBì—ì„œ ì¡°íšŒ
        log.info("ğŸ” Read from Replica")
        return userRepository.findByEmail(email) ?: throw RuntimeException("User not found")
    }

    @Transactional
    fun createUser(user: User): User {
        // ğŸ’¡ Master DBì— ì €ì¥
        log.info("ğŸ“ Write to Master")
        return userRepository.save(user)
    }
}
```

ì´ì œ readOnly ì˜µì…˜ì— ë”°ë¼ DB ë¥¼ ë¶„ë¦¬í•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# Outro

ì§€ê¸ˆê¹Œì§€ Spring ì˜ Transaction ì–´ë…¸í…Œì´ì…˜ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ ë³´ì•˜ìŠµë‹ˆë‹¤.  
Spring ìœ¼ë¡œ ë¡œì§ ì‘ì„± í•˜ì‹œë©´ì„œ ìì£¼ ì‚¬ìš©í•˜ê²Œ ë˜ì§€ë§Œ, ì–¼ë§ˆë‚˜ ë§ì€ ì˜µì…˜ë“¤ì´ ìˆëŠ” ì§€ ìì„¸íˆ ì‚´í´ê³  ì¨ì•¼ í•˜ëŠ” ê¸°ëŠ¥ì´ì£ .

ë„ì›€ì´ ë˜ì…¨ë‹¤ë©´ ë‹¤í–‰ì…ë‹ˆë‹¤. ë‹¤ìŒ ì£¼ì œëŠ” ì¢€ ë” Core ì´ì•¼ê¸°ë¥¼ í•´ë³¼ê¹Œ í•©ë‹ˆë‹¤. Spring Bean, ApplicationContext, Environment ì— ëŒ€í•´ì„œ ê¹Šê²Œ ë”¥ë‹¤ì´ë¸Œ í•´ ë³´ê² ìŠµë‹ˆë‹¤.

# Reference

- [https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html)
